{"meta":{"title":"Mihu的小世界","subtitle":"Hello World","description":"Keep learning & having fun :)","author":"Mihu","url":"https://mihuuu.github.io","root":"/"},"pages":[],"posts":[{"title":"数据库","slug":"数据库","date":"2019-03-29T11:40:13.000Z","updated":"2019-03-29T12:21:01.346Z","comments":true,"path":"2019/03/29/数据库/","link":"","permalink":"https://mihuuu.github.io/2019/03/29/数据库/","excerpt":"数据库ACID 原子性 Atomicity 事务的所有操作要么全部提交成功（commit），要么全部失败回滚（rollback） 回滚可以通过回滚日志来实现，反向执行修改操作。 一致性 Consistency 在一致性状态下，所有事务对一个数据的读取结果都是相同的。 隔离性 Isolation 一个事务所做的修改在最终提交以前，对其它事务是不可见的。 持久性 Durability 事务提交后所做的修改会永远保存到数据库中，即使数据库发生奔溃，事务执行结果也不会丢失。 无并发时，事务串行一定满足隔离性，此时只要满足原子性，就一定能满足一致性。 并发时，事务要满足原子性和隔离性才能满足一致性。","text":"数据库ACID 原子性 Atomicity 事务的所有操作要么全部提交成功（commit），要么全部失败回滚（rollback） 回滚可以通过回滚日志来实现，反向执行修改操作。 一致性 Consistency 在一致性状态下，所有事务对一个数据的读取结果都是相同的。 隔离性 Isolation 一个事务所做的修改在最终提交以前，对其它事务是不可见的。 持久性 Durability 事务提交后所做的修改会永远保存到数据库中，即使数据库发生奔溃，事务执行结果也不会丢失。 无并发时，事务串行一定满足隔离性，此时只要满足原子性，就一定能满足一致性。 并发时，事务要满足原子性和隔离性才能满足一致性。 并发一致性问题 脏读 不可重复读 幻影读 隔离级别 未提交读 Read Uncommitted 提交读 Read Committed 可重复读 Repeatable Read 可串行化 Serializable 隔离级别 脏读 不可重复读 幻影读 加锁读 未提交读 √ √ √ × 提交读 × √ √ × 可重复读 × × √ × 可串行化 × × × √ 三大范式 第一范式 1NF 第二范式 2NF 第三范式 3NF MySQLB+树 / B-树平衡树 为什么不用红黑树等数据结构？ 内/外/左/右连接索引MySQL索引背后的数据结构及算法原理 InnoDB 数据文件就是索引文件。叶节点data域保存了完整的数据记录，这种索引叫聚簇索引 (Clustered index) InnoDB 默认对主键建立索引；如果没有显式指定主键，MySQL 会自动选择一个可以唯一标识数据记录的列作为主键；如果不存在这种列，则 MySQL 自动生成一个隐含字段作为主键 辅助索引data域存储的是对应主键的值。使用辅助索引需要两遍检索，首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。 一个叶子节点内的数据记录按照主键顺序存放，因此每次有一条新记录插入时，要根据主键插入适当的节点和位置；如果使用自增主键，每次新增记录就会顺序添加到节点的后续位置，效率很高。 因为所有的辅助索引都会引用主索引，不建议使用过长的字段作为主键，否则会使辅助索引变得过大； 用非单调的字段作为主键也不好，插入新数据时为了维持B+树特性要频繁调整，所以建立使用自增字段 (AUTO_INCREMENT)。 MyISAM 索引文件和数据文件是分离的 叶节点的data域存放的是数据记录的地址（非聚簇索引） 每次读取磁盘获取数据，消耗时间 辅助索引data域存放的也是地址 InnoDB 和 MyISAM 的区别 InnoDB 是事务型的，可执行 commit / rollback InnoDB 支持行级锁，MyISAM 只支持表级锁 MyISAM 适用于需要大量查询的应用（大量写操作不好，会锁整张表） 索引的优缺点： 优点：加快查询速度；排序与分组 缺点：1. 索引需要额外存储空间 2.插入/删除数据时维护索引的开销 性能优化20+条MySQL性能优化的最佳经验 可以使用 Explain 来分析 SELECT 语句 优化数据查询 使用索引覆盖查询，减少扫描的行数 减少返回的行：使用 LIMIT 语句来限制返回数据（只要一行时用 LIMIT 1） 减少返回的列：尽量避免使用 SELECT *，需要什么字段就取什么 切分 水平切分 将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，sharding 可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。 垂直切分 将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。eg: 将电商数据库垂直切分成商品数据库、用户数据库等。 注意：切分的表不要经常 Join，否则性格比不切分还要差好多。 分区 SQL语句NoSQL","categories":[],"tags":[{"name":"Database","slug":"Database","permalink":"https://mihuuu.github.io/tags/Database/"}]},{"title":"pic","slug":"pic","date":"2019-03-29T11:26:23.000Z","updated":"2019-03-29T11:27:04.956Z","comments":true,"path":"2019/03/29/pic/","link":"","permalink":"https://mihuuu.github.io/2019/03/29/pic/","excerpt":"","text":"图片","categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://mihuuu.github.io/tags/test/"}]},{"title":"hahaha","slug":"hahaha","date":"2019-03-29T09:46:43.000Z","updated":"2019-03-29T09:50:20.345Z","comments":true,"path":"2019/03/29/hahaha/","link":"","permalink":"https://mihuuu.github.io/2019/03/29/hahaha/","excerpt":"","text":"Hellodjsdiwjqi","categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://mihuuu.github.io/tags/test/"}]},{"title":"test_my_site","slug":"test-my-site","date":"2018-10-24T15:32:43.000Z","updated":"2019-03-29T11:17:46.169Z","comments":true,"path":"2018/10/24/test-my-site/","link":"","permalink":"https://mihuuu.github.io/2018/10/24/test-my-site/","excerpt":"","text":"NONONOFIRST我是一个人的猪 SEC你呢","categories":[],"tags":[{"name":"test","slug":"test","permalink":"https://mihuuu.github.io/tags/test/"}]}]}